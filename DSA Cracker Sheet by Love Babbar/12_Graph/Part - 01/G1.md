
## Overview of Graph

### G-1: Introduction to Graph | Types | Different Conventions Used
    - Linear and Non-linear
    - Definitions and terminology: Node/vertex, Edge
    - Types: UG, DG
    - Structure: nodes + edge minimal condition for consider as graph, Cyclic-atleast 1, Acyclic
    - Path
    - Degree: In, Out, total D of G: 2 * E (no. of edges)
    - Weight

### G-2: Graph Representation in C++ | Two Ways to Represent
    - Input format 
    - representation: 
      1. adj matrix 
          - consumed more unused space (n^2)
      2. adj list 
          - SC - - O(2*E)

<br>


### (1) adj Matrix
-----------------------------------------
> 1 - adjacency matrix for undirected graph
>>   SC: O(n^2)
>
>  <em> Note: </em>
>>  We can use adj matrix for the smaller value of the no. of nodes
>>  <br>
>>  N - no. of nodes, M - No. of edges
>
>
-----------------------------------------

<br>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {


 // adjacency matrix for undirected graph

    int N, M;            
    cin >> N >> M;

    int adj[N + 1][N + 1];

    for(int i=0; i<M; i++) {

        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1;  // this statement will be removed in case of directed graph
    }




// Weighted graph for adj matrix

    int N, M, WT;       
    cin >> N >> M >> WT;

    int adjM[N+1][N+1];

    for(int i=0; i<M; i++) {

        int u, v;
        cin >> u >> v;
        adjM[u][v] = WT;
        adjM[v][u] = WT;  // this statement will be removed in case of directed graph
    }

    return 0;
}
```


<br>

### (1) adj list
-----------------------------------------
>>    adj list for undirected graph
>>    <br>
>>    TC: O(n * 2E)
> 
>>    adj list for directed graph
>>   <br>
>>    TC: O(n * E)
>
>>    adj list for undirected wt graph
>     <br>
>>    TC: O(n * 2E) + 2E
>
>>    adj list for directed wt graph
>     <br>
>>    TC: O(n * E) + 2E
----------------------------------------- 

<br>


## [02 - Creating and Printing (CN)](https://www.codingninjas.com/studio/problems/creating-and-printing_1214551?leftPanelTabValue=PROBLEM) 
----------------------------------
> <b>Note that </b>,
>>   here not provide the adj list. So we need to create adj list first.

### Algorithms,

 ```Step-01:```
   > Create an vector of size ‘N’ to store the graph. Let’s name this ‘ans’.
     
 ```Step-02:```  
   > Run a loop of <b>‘i’</b> from <b>0</b> to <b>‘M’</b> and do:
   >    - ans<b>[edges[i][0]]</b>.push_back(<b>ans[edges[i][1]]</b>)
   >    - ans<b>[edges[i][1]]</b>.push_back(<b>ans[edges[i][0]]</b>)
        
```Step-03:``` 
   > Create an vector <b>'adj'</b> size of <b>'N'</b> 
      
```Step-04:``` 
   > Run a loop of <b>‘i’</b> from <b>0</b> to <b>‘N’</b> and do:
   >    - adj[i].push_back(i)
   > Run a loop of <b>‘j’</b> from <b>0</b> to <b>ans[i].size()</b> and do:
   >    - adj[i].push_back(i)
   >       - insert ans[i][j] to the adj[i]

```Step-05:``` 
   > Finally, return the <b>‘adj’</b>.
----------------------------------

```cpp
vector<vector<int>> printAdjacency(int N, int M, vector<vector<int>> & edges) {
    
    // ans V will store the, all adj node correspoding to the indexes
    vector<int>ans[N];

    // for from 0 -> m (for edges)
    for(int i=0; i<M; i++) {

        int u = edges[i][0];
        int v = edges[i][1];
        
        ans[u].push_back(v);
        ans[v].push_back(u);
    } 

    
    // creating adj size of N
    vector < vector<int>> adj(N);

    for(int i=0; i<N; i++) {

        adj[i].push_back(i);

        // Entering the all neighbours
        for(int j=0; j<ans[i].size(); j++) {

            adj[i].push_back(ans[i][j]);
        }
    }
    return adj;
}
```

<br>

--------------------------------------------------------------------------------------------------------
>>
>> **Time Complexity**: O(N + M)
>> - Where N = no. of Nodes, M = no. of edges
>> - We are traversing each node and each edge of the graph, so the overall time complexity is O(N + M)
>   
>> **Space Complexit**y: O(N + M)
>> - ans and adjlist vector both contain a total of N nodes and M edge. So, the overall space complexity is O(N + M).
>> 
--------------------------------------------------------------------------------------------------------

<br>


## here, adjlist are given.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {


    int N, M;
    cin >> N >> M;

    vector<int> adj[N + 1];

    for(int i=0; i<M; i++) {

        int u, v;
        cin >> u >> v;

        adj[u].push_back(v);
        adj[v].push_back(u);  // this statement will be removed in case of directed graph
    }




// adj list for weighted graph

    int N, M;
    cin >> N >> M;

    vector<pair<int, int>> adj[N + 1];

    for(int i=0; i<M; i++) {

        int u, v, wt;
        cin >> u >> v >> wt;

        adj[u].push_back({v, wt});
        adj[v].push_back({u, wt});  // this statement will be removed in case of directed graph
    }
    return 0;
}
```
